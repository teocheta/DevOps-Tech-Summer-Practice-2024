Streams:

-> three default streams in the system

1. Standard input:

->  file descriptor is 0, STDIN

$ ls -al /dev/fd/ = file descriptors directory

    0
    1
    2
    proc/<number>/fd/

$ tty = terminal through which we communicate with operating system

2. Standard output:

-> when STDIN is waiting for instructions passed to it, standard output displays responses from the system (in the simplest scenario)
-> file descriptor is 1, STDOUT

3. Standard error:

-> file descriptor 2, STDERR

How to use streams:

$ cat notexists.txt 2> errorfile = we directed all 2 (what means file descriptor for standard error) to file

$ cat notexists.txt 2> /dev/null = redirect error to nowhere

$ cat notexists.txt 1> catfile 2> errorfile =  directed STDOUT to catfile which can be our execution log (or whatever you wish) and, if we have error, we write it to errorfile

-> cat prints the content to STDOUT

$ cat notexists.txt > capture.txt 2>&1 = STDOUT and STDERR in the same file ( 2>&1 = redirect stream 2 (STDERR), to the same destination as stream 1 (STDOUT), is being redirected to)

->  how we can capture the information what STDIN is used, and act accordingly

#!/bin/bash
if [ -t 0 ]; then
  echo stdin coming from keyboard
else
  echo stdin coming from a pipe or a file
fi

$ ./script.sh

$ ./script.sh < dummy.txt

$ cat dummy.txt | ./script.sh

->  script checks the origin of input data

-> how to create /dev/null

$ mknod -m 0666 /dev/null c 1 3

    mknod creates a speacial file
    -m 0666 says about file permission
    /dev/null is the name
    c is the device type
    1 3 are the MAJOR and MINOR numbers to specify the device

    -> device types: p for a FIFO
                    b for a block special file
                    c for a character special file

    ->  MAJOR and MINOR numbers =  not random; the specific pairs are defined in Kernel


